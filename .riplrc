
require 'ripl'
require 'ripl/multi_line'

module Ripl::RiplRc
  def squeeze_history
    history.to_a.inject([]){ |result, item|
      if result.last == item
        result
      else
        result << item
      end
    }
  end

  # write squeezed history
  def write_history
    File.open(history_file, 'w'){ |f| f.puts squeeze_history.join("\n") }
  end

  # squeeze history on memory too
  def eval_input input
    history.pop if input.strip == '' ||
                  (history.size > 1 && input == history[-2])
    super
  end

  # make ctrl-d end with a newline
  def after_loop
    puts unless @input
    super
  end

  # don't print empty input
  def print_result result
    super unless @input.strip == ''
  end

  def format_result result
    colors = {
      String     => :green  ,
      Numeric    => :red    ,
      Symbol     => :cyan   ,
      Array      => :blue   ,
      Hash       => :blue   ,
      NilClass   => :magenta,
      TrueClass  => :magenta,
      FalseClass => :magenta,
      Object     => :yellow
    }

    case result
      when String ; send(colors[String      ]){ "'#{result}'"  }
      when Numeric; send(colors[Numeric     ]){ result         }
      when Symbol ; send(colors[Symbol      ]){ ":#{result}"   }
      when Array  ; send(colors[Array       ]){ '['            }  +
                    result.map{ |e| format_result(e) }.join(
                    send(colors[Array       ]){ ', '           }) +
                    send(colors[Array       ]){ ']'            }
      when Hash   ; send(colors[Hash        ]){ '{'            }  +
                    result.map{ |k, v| format_result(k)           +
                    send(colors[Hash        ]){ '=>'           }  +
                                       format_result(v) }.join(
                    send(colors[Hash        ]){ ', '           }) +
                    send(colors[Hash        ]){ '}'            }
      else        ; if colors[result.class]
                    send(colors[result.class]){ result.inspect }
                    else
                    send(colors[Object      ]){ result.inspect }
                    end
    end
  end

  def color rgb
    "\x1b[#{rgb}m" + (block_given? ? "#{yield}#{reset}" : '')
  end

  def   black &block; color(30, &block); end
  def     red &block; color(31, &block); end
  def   green &block; color(32, &block); end
  def  yellow &block; color(33, &block); end
  def    blue &block; color(34, &block); end
  def magenta &block; color(35, &block); end
  def    cyan &block; color(36, &block); end
  def   white &block; color(37, &block); end
  def   reset &block; color('', &block); end
end

Ripl::Shell.include(Ripl::RiplRc)

Ripl.config[:irbrc]   = nil
Ripl.config[:history] = '~/.config/irb/irb_history'

if $PROGRAM_NAME == __FILE__
  require 'bacon'
  require 'rr'
  require 'fileutils'
  Bacon.summary_on_exit
  include RR::Adapters::RRMethods
  describe Ripl::RiplRc do
    before do
      @history = '/tmp/test_ripl_history'
      @shell   = Ripl::Shell.create(Ripl.config.merge!(:history => @history))
      @input   = %w[foo bar bar foo bar]
      @shell.history.clear
    end

    after do; FileUtils.rm_f(@history); end

    should 'after_loop saves squeezed history' do
      @shell.history.push(*@input)
      @shell.instance_variable_set('@input', '')
      @shell.after_loop
      File.read(@history).should == %w[foo bar foo bar].join("\n") + "\n"
    end

    should 'loop_once squeeze history' do
      times = @input.size
      stub(@shell).get_input{ (@shell.history << "'#{@input.shift}'")[-1] }
      stub(@shell).print_result(anything)
      times.times{ @shell.loop_once }
      @shell.history.to_a.should == %w[foo bar foo bar].map{ |i| "'#{i}'" }
    end
  end
end
