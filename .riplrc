
require 'ripl'
require 'ripl/multi_line'

module Ripl::RiplRc
  def squeeze_history
    history.to_a.inject([]){ |result, item|
      if result.last == item
        result
      else
        result << item
      end
    }
  end

  # write squeezed history
  def write_history
    File.open(history_file, 'w'){ |f| f.puts squeeze_history.join("\n") }
  end

  # squeeze history on memory too
  def eval_input input
    history.pop if input.strip == '' ||
                  (history.size > 1 && input == history[-2])
    super
  end

  # make ctrl-d end with a newline
  def after_loop
    puts unless @input
    super
  end

  # don't print empty input
  def print_result result
    super unless @input.strip == ''
  end
end

Ripl::Shell.include(Ripl::RiplRc)

Ripl.config[:irbrc]   = nil
Ripl.config[:history] = '~/.config/irb/irb_history'

if $PROGRAM_NAME == __FILE__
  require 'bacon'
  require 'rr'
  require 'fileutils'
  Bacon.summary_on_exit
  include RR::Adapters::RRMethods
  describe Ripl::RiplRc do
    before do
      @history = '/tmp/test_ripl_history'
      @shell   = Ripl::Shell.create(Ripl.config.merge!(:history => @history))
      @input   = %w[foo bar bar foo bar]
      @shell.history.clear
    end

    after do; FileUtils.rm_f(@history); end

    should 'after_loop saves squeezed history' do
      @shell.history.push(*@input)
      @shell.instance_variable_set('@input', '')
      @shell.after_loop
      File.read(@history).should == %w[foo bar foo bar].join("\n") + "\n"
    end

    should 'loop_once squeeze history' do
      times = @input.size
      stub(@shell).get_input{ (@shell.history << "'#{@input.shift}'")[-1] }
      stub(@shell).print_result(anything)
      times.times{ @shell.loop_once }
      @shell.history.to_a.should == %w[foo bar foo bar].map{ |i| "'#{i}'" }
    end
  end
end
